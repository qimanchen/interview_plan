# KMP算法
- 问题描述
	子串或子序列包含问题
- 子串
- 子序列
	不连续或连续
- 解决方法
	- 笨办法
		str1 和 str2 依次配置，当配置失败时，每次回到开头index+1进行配置
		O(N*M) 
	- KMP思想
		一个字符前面字符串最长相同的前缀和后缀
		限定：
			前缀不能包含第一字符
			后缀不能包含最后一个字符
		
		- 步骤
			- 先处理str2，使用next_str数组存储每个字符的最长前缀和最长后缀
				额外的信息
				a	b	a	b	a	c
				-1	0	0	1	2	3
			- 从最长后缀的str1中的开始位置往下配，对应str2中最长前缀的下一位置进行配
			- 流程的实质
				str1	i			j	x
				str2	0				y
				否定了j位置以前的字符不会匹配
				公式：
				j = x - next_str[y]
				下一次str2匹配位置为next_str[y] + 1 与str1[x]
				如果不等：再次匹配 next_str[next_str[y]]的情况
		- 求next数组
			0位置 -1
			1位置 0
			利用前面的结果求i位置的最长前缀和后缀
			长度4	长度4	b	a
							i-1	i
			看长度为4的下一字符，看是否为b,如果为b那么就是4