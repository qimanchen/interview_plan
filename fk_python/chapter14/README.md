# 并发编程
单线程只有一个顺序执行流，多线程包含多个顺序执行流，且每个之间互不影响

# 线程描述
	一个运行中的任务对应着一个进程（process）
	进程：处于运行中的程序；进程是系统进行资源分配和调度的一个独立单位
		1. 独立性 -- 每个进程拥有私有的地址空间
		2. 动态性 -- 相较于程序，正在系统中活动的指令集，进程中加入了时间的概念
		3. 并发性 -- 多个进程在单个处理器上，并发执行
	
	# 并发与并行
		1. 并行 -- 同一时刻有多条指令在多个处理器上同时执行
		2. 并发 -- 同一时刻只能有一条指令执行，但轮换速度快，宏观上同时进行
	
	# 多线程 -- 同一个进程可以同时并发处理多个任务
		线程被称为轻量级的进程，线程是进程的执行单元
		一个进程可以拥有多个线程，一个线程必须有一个父进程
		
		多个线程间共享进程所拥有的全部资源
		线程的运行是抢占式的
		一个线程可以创建和撤销另一个线程，同一个进程中的多个线程间可以并发运行
	
	一个进程至少有个主线程
	
	# 线程的优势
		1. 隔离程度小，共享内存，文件句柄和其他进程应有的状态
		2. 线程划分尺度小于进程，多线程并发性高
		3. 创建简单，代价小，容易实现通信
		
		
# 线程的创建和启动
	# 创建线程
		1. 使用threading模块的Thread类的构造器创建
		2. 继承threading模块的Thread类创建线程类
		
		threading.Thread(group=None, target=None, name=None, args=(), kwargs=None, *, daemon=None)
			group -- 该线程所属的线程组
			target -- 指定该线程要调度的目标方法
			args -- 指定一个元组，以位置参数的形式为target指定的参数传入参数
			kwargs -- 指定一个字典，以关键字形式为target传递指定参数
			daemon -- 所构建的线程是否为后代线程
		
		创建线程对象
			t1 = threading.Thread(target=action, args=(100,))
			t1.start()
			python程序存在一个默认的主线程，默认称号MainThread,Thread-1
		start()方法启动线程
		
		threading.current_thread() -- 返回当前正在执行的线程对象
		threading.current_thread().getName() -- Thread类的实例方法，返回调用它的线程名称
		
		# 继承Thread类创建线程类
			1. 定义Thread类的子类，并重写该类的run()方法 -- 线程执行体
			2. 创建Thread子类的实例对象
			3. 调用对象start()方法启动线程
		
		# 直接使用构造器创建线程类 -- 编程简单，逻辑结构简单
		

# 线程的生命周期
	线程的生命周期中需要经过：
		1. 新建 -- New
		2. 就绪 -- Ready -- 表示该线程可以运行 -- 等待执行
		3. 运行 -- Running
		4. 阻塞 -- Blocked
		5. 死亡 -- Dead
		线程状态是在运行和就绪之间转换
		
	线程对象在调用start()方法后，则该线程处于就绪状态
	python解释器会为其创建方法调用栈和程序计数器
	run()方法直接调用就是一个普通的对象，而且当调用run()方法后，其已经初始处于新建状态
	
	# 只能对处于新建状态的线程调用start()方法，如果对一个线程多次调用start()方法，将引发RuntimeError异常
	
	# 就绪态获得cpu后就执行线程执行体，该线程处于运行状态
	
	抢占式
	
	# 当线程遇到以下情况时，会进入阻塞状态：
		线程调用sleep()方法主动放弃占用的资源
		线程调用了一个阻塞式I/O方法，在该方法返回前该线程会被阻塞
		线程尝试获取锁，但锁被其他线程持有
		线程在等待某个通知
		
		上述结果完成 -- 阻塞态结束后 -- 进入就绪态
	
	# 就绪态和运行态之间的转换是由系统线程调度决定的
	
	当运行状态的线程失去处理器资源时，该线程进入就绪态
	
	# 线程结束
		1. run()方法 或 target函数执行完成 -- 正常结束
		2. 线程抛出一个未捕获的exception或error
		
	# 一旦子线程启动起来后，它拥有和主线程相同的地位 -- 不受主线程的影响
	
	# 线程对象的状态 -- 调用线程对象的方法 is_alive():
		1. 就绪，运行，阻塞 --- True
		2. 新建，死亡 --- True
		
		
# 控制线程
	# join线程
		join() -- 让一个线程等待另一个线程完成的方法
			当在某个程序执行流中调用其他线程的join()方法时，调用线程将被阻塞，直到join()方法加入的join线程执行完成
			大问题 -- 小问题
		
	
